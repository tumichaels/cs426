package raft

// I like enums (generated by chatgpt)
// Define a struct to represent a RaftState
type RaftRole struct {
	name string
}

// Declare the possible states as constants
var (
	Follower  = RaftRole{"Follower"}
	Candidate = RaftRole{"Candidate"}
	Leader    = RaftRole{"Leader"}
)

// generic log structure inspired by logcabin/logcabin on github
// this is reference [21] in the paper!
// *note* that it's the literal canonical implementation
type Entry struct {
	Data interface{}
	Term int
}

type Log interface {
	GetEntry(int) Entry
	GetEntriesStartingFrom(int) []Entry
	GetLastLogIndex() int
	DeleteEntriesFrom(int)
	AppendEntry(Entry)
	AppendEntries([]Entry)
	GetFirstIndex(term, index int) int
}

type InMemoryLog struct {
	Arr []Entry
}

func MakeInMemoryLog() *InMemoryLog {
	log := InMemoryLog{make([]Entry, 0)}
	return &log
}

func (iml *InMemoryLog) GetEntry(idx int) Entry {
	// for first item, you request (1-1) + 1 + 0 = 1
	// consider changing first hearbeat to request (1-1) + 1 + 0 = 1 instead
	if idx == 0 {
		return Entry{nil, 0}
	}
	return iml.Arr[idx-1]
}

func (iml *InMemoryLog) GetEntriesStartingFrom(idx int) []Entry {
	if idx <= 0 {
		return iml.Arr
	}
	if idx-1 >= len(iml.Arr) {
		return []Entry{}
	}
	return iml.Arr[idx-1:]
}

func (iml *InMemoryLog) GetLastLogIndex() int {
	return len(iml.Arr)
}

func (iml *InMemoryLog) DeleteEntriesFrom(idx int) {
	iml.Arr = iml.Arr[:idx-1]
}

func (iml *InMemoryLog) AppendEntry(e Entry) {
	iml.Arr = append(iml.Arr, e)
}

func (iml *InMemoryLog) AppendEntries(e []Entry) {
	iml.Arr = append(iml.Arr, e...)
}

func (iml *InMemoryLog) GetFirstIndex(term, index int) int {
	for i := index - 1; i >= 0; i-- {
		entry := iml.Arr[i]
		if entry.Term != term {
			return i + 2 // Convert back to 1-based indexing
		}
	}
	return 1 // Return 1 if this is first term in log
}
