package raft

import (
	"flag"
	"fmt"
	"log"
	"path/filepath"
	"runtime"
)

// Debugging
var Debug = flag.Bool("debug", false, "whether to print debug logs")

func init() {
	log.SetFlags(log.LstdFlags | log.Lmicroseconds)
}

func DPrintf(format string, a ...interface{}) {
	if *Debug {
		_, path, line, _ := runtime.Caller(1 /*skip*/)
		file := filepath.Base(path)
		msg := fmt.Sprintf(format, a...)
		log.Printf("%s (%v:%v)", msg, file, line)
	}
}

func DPrintfFromNode(me int, format string, a ...interface{}) {
	if *Debug {
		_, path, line, _ := runtime.Caller(1 /*skip*/)
		file := filepath.Base(path)
		msg := fmt.Sprintf(format, a...)
		log.Printf("[Node %d] %s (%v:%v)", me, msg, file, line)
	}
}

// I like enums (generated by chatgpt)
// Define a struct to represent a RaftState
type RaftRole struct {
	name string
}

// Declare the possible states as constants
var (
	Follower  = RaftRole{"Follower"}
	Candidate = RaftRole{"Candidate"}
	Leader    = RaftRole{"Leader"}
)

// generic log structure inspired by logcabin/logcabin on github
// this is reference [21] in the paper!
// *note* that it's the literal canonical implementation
type Entry struct {
	Data interface{}
	Term int
}

type Log interface {
	GetEntry(int) Entry
	GetLastLogIndex() int
	DeleteEntriesFrom(int)
	AppendEntry(Entry)
}

type InMemoryLog struct {
	arr []Entry
}

func MakeInMemoryLog() *InMemoryLog {
	log := InMemoryLog{make([]Entry, 0)}
	return &log
}

func (iml *InMemoryLog) GetEntry(idx int) Entry {
	if idx == 0 {
		return Entry{nil, 0}
	}
	return iml.arr[idx-1]
}

func (iml *InMemoryLog) GetLastLogIndex() int {
	return len(iml.arr)
}

func (iml *InMemoryLog) DeleteEntriesFrom(idx int) {
	iml.arr = iml.arr[:idx-1]
}

func (iml *InMemoryLog) AppendEntry(e Entry) {
	iml.arr = append(iml.arr, e)
}
